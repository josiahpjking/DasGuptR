% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dgnpop.R
\name{dgnpop}
\alias{dgnpop}
\title{Prithwis Das Gupta's 1993 standardisation and decomposition of rates over P rate-factors and N populations.}
\usage{
dgnpop(
  x,
  pop,
  factors,
  id_vars = NULL,
  crossclassified = NULL,
  ratefunction = NULL,
  baseline = NULL,
  quietly = TRUE
)
}
\arguments{
\item{x}{dataframe or tibble object, with columns specifying 1) population, 2) each rate-factor to be considered, and (optionally) 3) variables indicating underlying subpopulations}

\item{pop}{name (character string) of variable indicating population}

\item{factors}{names (character vector) of variables indicating compositional factors}

\item{id_vars}{character vector of variables indicating sub-populations}

\item{crossclassified}{character string of variable indicating size of sub-population. If specified, the proportion of each population in a given sub-population (e.g. each age-sex combination) is re-expressed as a product of symmetrical expressions representing the different variables (age, sex) constituting the sub-populations. These expressions are then used as compositional factors in the standardisation. If NULL, then providing a single variable as a compositional factor that represents the proportion of the population in each given sub-population will combine the contribution of all sub-population variables.}

\item{ratefunction}{user defined character string in R syntax that when evaluated specifies the function defining the rate as a function of factors. if NULL then will assume rate is the product of all factors. When sub-populations are provided, this should aggregate to a summary value (e.g., for the simple product rate this should be provided as `"sum(A*B*C*)"`.). User-defined functions can also be provided, as whatever string is given here will be parsed and evaluated as any other R code (see example eg4.4).}

\item{baseline}{baseline population to standardise against. if NULL then will do Das Gupta's full N-population standardisation.}

\item{quietly}{logical indicating whether interim messages should be outputted indicating progress through the P factors and N populations}
}
\value{
data.frame with TODO finish this
}
\description{
Population rates are often composed of various different compositional factors. For example, Das Gupta 1992 expressed the birth rate as the product of the fertility rate, proportion of women who are of childbearing ages, and the proportion of women in the population. Comparisons of crude rates between populations can be misleading as different compositional factors may be contributing to different extents on any observed differences in the crude rate. Standardisation of rates ... TODO finish this description
}
\examples{
# 2 factors, 2 populations, R=ab
eg2.1 <- data.frame(
  pop = c("black","white"),
  avg_earnings = c(10930, 16591),
  earner_prop = c(.717892, .825974)
)
dgnpop(eg2.1, pop="pop",factors=c("avg_earnings", "earner_prop")) |>
  dg_table()


# 4 factors, 2 populations, R=abcd
eg2.5 <- data.frame(
  pop = c(1971, 1979),
  birth_preg = c(25.3, 32.7),
  preg_actw = c(.214, .290),
  actw_prop = c(.279, .473),
  w_prop = c(.949, .986)
)
dgnpop(eg2.5, pop="pop", c("birth_preg", "preg_actw", "actw_prop", "w_prop")) |>
  dg_table()

# 2 factors, 2 populations, R=f(a,b)
eg3.1 <- data.frame(
  pop = c(1940,1960),
  crude_birth = c(19.4, 23.7),
  crude_death = c(10.8, 9.5)
)
# crude rates
eg3.1$crude_birth - eg3.1$crude_death

dgnpop(eg3.1, pop="pop",c("crude_birth","crude_death"),
       ratefunction = "crude_birth-crude_death") |>
  dg_table()


# 3 vector factors, 2 populations, R=sum(ABC)
eg4.5 <- data.frame(
  agegroup = rep(1:7, 2),
  pop = rep(c(1970, 1960), e = 7),
  bm = c(488, 452, 338, 156, 63, 22, 3,
         393, 407, 369, 274, 184, 90, 16),
  mw = c(.082, .527, .866, .941, .942, .923, .876,
         .122, .622, .903, .930, .916, .873, .800),
  wp = c(.058, .038, .032, .030, .026, .023, .019,
         .043, .041, .036, .032, .026, .020, .018)
)
dgnpop(eg4.5, pop="pop", c("bm", "mw", "wp"),
       id_vars=c("agegroup"),ratefunction = "sum(bm*mw*wp)") |>
  dg_table()



# 4 vector factors, 2 populations, R=f(A,B)
# rate as function of vector factors
eg4.4 <- data.frame(
  pop=rep(c(1963,1983),e=6),
  agegroup=c("15-19","20-24","25-29","30-34","35-39","40-44"),
  A = c(.200,.163,.146,.154,.168,.169,
        .169,.195,.190,.174,.150,.122),
  B = c(.866,.325,.119,.099,.099,.121,
        .931,.563,.311,.216,.199,.191),
  C = c(.007,.021,.023,.015,.008,.002,
        .018,.026,.023,.016,.008,.002),
  D = c(.454,.326,.195,.107,.051,.015,
        .380,.201,.149,.079,.025,.006)
)
# rate function of sum(ABC) / (sum(ABC) + sum(A(1-B)D))

# crude rates:
with(eg4.4[1:6,], sum(A*B*C) / (sum(A*B*C) + sum(A*(1-B)*D)) )
with(eg4.4[7:12,], sum(A*B*C) / (sum(A*B*C) + sum(A*(1-B)*D)) )

dgnpop(eg4.4, pop="pop",factors=c("A","B","C","D"), id_vars = "agegroup",
       ratefunction="sum(A*B*C) / (sum(A*B*C) + sum(A*(1-B)*D))") |>
  dg_table()

# alternatively:
myratef <- function(a,b,c,d){
  return( sum(a*b*c) / (sum(a*b*c) + sum(a*(1-b)*d))  )
}
dgnpop(eg4.4, pop="pop",factors=c("A","B","C","D"), id_vars = "agegroup",
       ratefunction="myratef(A,B,C,D)") |>
  dg_table()



# cross-classified rates, 2 populations
eg5.3 <- data.frame(
  race = rep(rep(1:2, e=11),2),
  age = rep(rep(1:11,2),2),
  pop = rep(c(1985,1970), e=22),
  size = c(3041,11577,27450,32711,35480,27411,19555,19795,15254,8022,2472,
           707,2692,6473,6841,6547,4352,3034,2540,1749,804,236,
           2968,11484,34614,30992,21983,20314,20928,16897,11339,5720,1315,
           535,2162,6120,4781,3096,2718,2363,1767,1149,448,117),
  rate = c(9.163,0.462,0.248,0.929,1.084,1.810,4.715,12.187,27.728,64.068,157.570,
           17.208,0.738,0.328,1.103,2.045,3.724,8.052,17.812,34.128,68.276,125.161,
           18.469,0.751,0.391,1.146,1.287,2.672,6.636,15.691,34.723,79.763,176.837,
           36.993,1.352,0.541,2.040,3.523,6.746,12.967,24.471,45.091,74.902,123.205)
)

dgnpop(eg5.3, pop = "pop", factors=c("rate"), id_vars = c("race","age"),
       crossclassified = "size") |>
  dg_table()



# 4 vector factors, 5 populations, R=f(A,B)
# rate as function of vector factors
eg6.6 <- data.frame(
  pop=rep(c(1963,1968,1973,1978,1983),e=6),
  agegroup=c("15-19","20-24","25-29","30-34","35-39","40-44"),
  A = c(.200,.163,.146,.154,.168,.169,
        .215,.191,.156,.137,.144,.157,
        .218,.203,.175,.144,.127,.133,
        .205,.200,.181,.162,.134,.118,
        .169,.195,.190,.174,.150,.122),
  B = c(.866,.325,.119,.099,.099,.121,
        .891,.373,.124,.100,.107,.127,
        .870,.396,.158,.125,.113,.129,
        .900,.484,.243,.176,.155,.168,
        .931,.563,.311,.216,.199,.191),
  C = c(.007,.021,.023,.015,.008,.002,
        .010,.023,.023,.015,.008,.002,
        .011,.016,.017,.011,.006,.002,
        .014,.019,.015,.010,.005,.001,
        .018,.026,.023,.016,.008,.002),
  D = c(.454,.326,.195,.107,.051,.015,
        .433,.249,.159,.079,.037,.011,
        .314,.181,.133,.063,.023,.006,
        .313,.191,.143,.069,.021,.004,
        .380,.201,.149,.079,.025,.006)
)
# crude rates:
eg6.6 |> dplyr::group_by(pop) |>
  dplyr::summarise(
    crude = sum(A*B*C) / (sum(A*B*C) + sum(A*(1-B)*D))
  )

dgnpop(eg6.6, pop="pop",factors=c("A","B","C","D"),id_vars="agegroup",
       ratefunction="1000*sum(A*B*C) / (sum(A*B*C) + sum(A*(1-B)*D))")$rates |>
  dplyr::select(-std.set) |>
  tidyr::pivot_wider(names_from=pop,values_from=rate)
}
