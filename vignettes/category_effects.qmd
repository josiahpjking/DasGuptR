---
title: "Category Effects in DG decomposition"
---

only for cross-classified data.  
using eg5.3 from DG 1993  

```{r}
eg5.3 <- data.frame(
  race = rep(rep(1:2, e=11),2),
  age = rep(rep(1:11,2),2),
  pop = rep(c(1985,1970), e=22),
  size = c(3041,11577,27450,32711,35480,27411,19555,19795,15254,8022,2472,
           707,2692,6473,6841,6547,4352,3034,2540,1749,804,236,
           2968,11484,34614,30992,21983,20314,20928,16897,11339,5720,1315,
           535,2162,6120,4781,3096,2718,2363,1767,1149,448,117),
  rate = c(9.163,0.462,0.248,0.929,1.084,1.810,4.715,12.187,27.728,64.068,157.570,
           17.208,0.738,0.328,1.103,2.045,3.724,8.052,17.812,34.128,68.276,125.161,
           18.469,0.751,0.391,1.146,1.287,2.672,6.636,15.691,34.723,79.763,176.837,
           36.993,1.352,0.541,2.040,3.523,6.746,12.967,24.471,45.091,74.902,123.205)
)
```


in order to do this, we need to get out the sub-population level standardised rates.  
but when we specificy `crossclassified` argument in `dgnpop()`, this will automatically aggregate up to population level.  

the work around is to create the set of population-structure variables (in which interaction effects are symmetrically spread across the different characteristics) *outside* of the decomposition. 
We can use the `split_popstr()` function to do that, but we need to do it for each population. Note that the new variables are provided with the suffix of "_struct" to distinguish them from the sub-population variables themselves: 
```{r}
eg5.3 <- dgcc(eg5.3, pop="pop", id_vars=c("age","race"), crossclassified = "size")
head(eg5.3)
```


then we do the standardisation using those structural variables as factors. 
Without specifying the ratefunction, this will return rates at the sub-population levels because we are giving the function vector factors:  
```{r}
res <- dgnpop(eg5.3, pop = "pop", factors=c("age_struct","race_struct","rate"),
              id_vars = c("race","age"))
head(res)
```

We can take those individual rates, and then following Chevin & Sutherland, calculate the category effect CE for each group i of race and j of age.  
```{r}
race_ce <- res |>
  pivot_wider(names_from=factor,values_from=rate) |>
  group_by(pop,race) |>
  summarise(
    IAi = sum(race_struct),
    RTi = sum(rate)*(1/2),
    CEi = IAi+RTi
  ) |>
  group_by(race) |>
  summarise(
    ce = diff(CEi)
  )

age_ce <- res |>
  pivot_wider(names_from=factor,values_from=rate) |>
  group_by(pop, age) |>
  summarise(
    JBj = sum(age_struct),
    RTj = sum(rate)*(1/2),
    CEj = JBj+RTj
  ) |>
  group_by(age) |>
  summarise(
    ce = diff(CEj)
  )
```

These are the category effects! Which when added up take us back to the difference in crude rates!  
```{r}
bind_rows(
  race_ce,
  age_ce
)
# total:
sum(c(race_ce$ce,age_ce$ce))
# same as crude diff T.. - t..
dgnpop(eg5.3, pop="pop",factors="rate",id_vars=c("race","age"),crossclassified = "size") |>
  dg_table()
```
all we need do is then divide these to get category effects as a % of the crude rate differences:

```{r}
bind_rows(
  race_ce,
  age_ce
) |> mutate(ce_perc = ce/sum(ce)*100) |>
  select(age,race,ce_perc) 
```

