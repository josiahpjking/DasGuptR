---
title: "Category Effects in DG decomposition"
editor_options: 
  chunk_output_type: console
---

For cross-classified data, [Chevan & Sutherland 2009](https://doi.org/10.1353/dem.0.0060){target="_blank"} provide a method for decomposing differences in rates into the  specific 
using eg5.3 from DG 1993  

```{r}
eg5.3 <- data.frame(
  race = rep(rep(1:2, e=11),2),
  age = rep(rep(1:11,2),2),
  pop = rep(c(1985,1970), e=22),
  size = c(3041,11577,27450,32711,35480,27411,19555,19795,15254,8022,2472,
           707,2692,6473,6841,6547,4352,3034,2540,1749,804,236,
           2968,11484,34614,30992,21983,20314,20928,16897,11339,5720,1315,
           535,2162,6120,4781,3096,2718,2363,1767,1149,448,117),
  rate = c(9.163,0.462,0.248,0.929,1.084,1.810,4.715,12.187,27.728,64.068,157.570,
           17.208,0.738,0.328,1.103,2.045,3.724,8.052,17.812,34.128,68.276,125.161,
           18.469,0.751,0.391,1.146,1.287,2.672,6.636,15.691,34.723,79.763,176.837,
           36.993,1.352,0.541,2.040,3.523,6.746,12.967,24.471,45.091,74.902,123.205)
)
```


in order to do this, we need to get out the sub-population level standardised rates.  
but when we specificy `crossclassified` argument in `dgnpop()`, this will automatically aggregate up to population level.  

the work around is to create the set of population-structure variables (in which interaction effects are symmetrically spread across the different characteristics) *outside* of the decomposition. 
We can use the `dgcc()` function to do that. Note that the new variables are provided with the suffix of "_struct" to distinguish them from the sub-population variables themselves: 
```{r}
eg5.3 <- dgcc(eg5.3, pop="pop", id_vars=c("age","race"), crossclassified = "size")
head(eg5.3)
```


then we do the standardisation using those structural variables as factors. 
Without specifying the ratefunction, this will return rates at the sub-population levels because we are giving the function vector factors:  
```{r}
res <- dgnpop(eg5.3, pop = "pop", factors=c("age_struct","race_struct","rate"),
              id_vars = c("race","age"))
head(res)
```

We can take those individual rates, and then following Chevin & Sutherland, calculate the category effect CE for each group i of race and j of age.  
```{r}
race_ce <- res |>
  pivot_wider(names_from=factor,values_from=rate) |>
  group_by(pop,race) |>
  summarise(
    IAi = sum(race_struct),
    RTi = sum(rate)*(1/2),
    CEi = IAi+RTi
  ) |>
  group_by(race) |>
  summarise(
    comp_ce = IAi[pop==1985] - IAi[pop==1970],
    rate_ce = RTi[pop==1985] - RTi[pop==1970],
    tot_ce = CEi[pop==1985] - CEi[pop==1970]
  )

age_ce <- res |>
  pivot_wider(names_from=factor,values_from=rate) |>
  group_by(pop, age) |>
  summarise(
    JBj = sum(age_struct),
    RTj = sum(rate)*(1/2),
    CEj = JBj+RTj
  ) |>
  group_by(age) |>
  summarise(
    comp_ce = JBj[pop==1985] - JBj[pop==1970],
    rate_ce = RTj[pop==1985] - RTj[pop==1970],
    tot_ce = CEj[pop==1985] - CEj[pop==1970]
  )
```

These are the category effects! Which when added up take us back to the difference in crude rates!  
```{r}
bind_rows(
  race_ce,
  age_ce
)
# total:
sum(c(race_ce$tot_ce,age_ce$tot_ce))
# same as crude diff T.. - t..
dgnpop(eg5.3, pop="pop",factors="rate",id_vars=c("race","age"),crossclassified = "size") |>
  dg_table()
```
all we need do is then divide these to get category effects as a % of the crude rate differences:

```{r}
bind_rows(
  race_ce,
  age_ce
) |>
  mutate(
    comp_ce = comp_ce/sum(tot_ce)*100,
    rate_ce = rate_ce/sum(tot_ce)*100,
    tot_ce = tot_ce/sum(tot_ce)*100
  ) 
```









```{r}
data(reconv)
srec <- reconv |> filter(year %in% c(2004,2016)) |>
  select(year,Sex,Age,offenders,prev_rate)

srec <- dgcc(srec, pop="year", id_vars=c("Age","Sex"), crossclassified = "offenders")

res <- dgnpop(srec, pop = "year", factors=c("Age_struct","Sex_struct","prev_rate"),
              id_vars = c("Age","Sex"))
head(res)
```

We can take those individual rates, and then following Chevin & Sutherland, calculate the category effect CE for each group i of race and j of age.  
```{r}
sex_ce <- res |>
  pivot_wider(names_from=factor,values_from=rate) |>
  group_by(pop,Sex) |>
  summarise(
    IAi = sum(Sex_struct),
    RTi = sum(prev_rate)*(1/2),
    CEi = IAi+RTi
  ) |>
  group_by(Sex) |>
  summarise(
    comp_ce = diff(IAi),
    rate_ce = diff(RTi),
    tot_ce = diff(CEi)
  )

age_ce <- res |>
  pivot_wider(names_from=factor,values_from=rate) |>
  group_by(pop, Age) |>
  summarise(
    JBj = sum(Age_struct),
    RTj = sum(prev_rate)*(1/2),
    CEj = JBj+RTj
  ) |>
  group_by(Age) |>
  summarise(
    comp_ce = diff(JBj),
    rate_ce = diff(RTj),
    tot_ce = diff(CEj)
  )

bind_rows(
  sex_ce,
  age_ce
)
# total:
sum(c(sex_ce$ce,age_ce$ce))
# same as crude diff T.. - t..
dgnpop(srec, pop = "year", factors=c("prev_rate"),
              id_vars = c("Age","Sex"), crossclassified = "offenders") |>
  dg_table()

bind_rows(
  sex_ce,
  age_ce
) |> 
  mutate(
    comp_ce = comp_ce/sum(tot_ce)*100,
    rate_ce = rate_ce/sum(tot_ce)*100,
    tot_ce = tot_ce/sum(tot_ce)*100
  ) 

colSums(dd[,2:4])
```
